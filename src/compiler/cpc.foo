;; Continuation Passing Converter
;; Assumes macro-expanded code.

(define (cpc expr kont)
  (cond ((simple-expression? expr) (kont (cpc-simple expr)))
        ((string? expr) (cpc-string expr kont))
        ((vector? expr) (cpc-vector expr kont))
        ((tagged-list? 'define expr) (cpc-define expr kont))
        ((tagged-list? 'do expr) (cpc-do expr kont))
        ((tagged-list? 'if expr) (cpc-if expr kont))
        ((tagged-list? 'letcc expr) (cpc-letcc expr kont))
        ((tagged-list? 'letrec expr) (cpc-letrec expr kont))
        ((tagged-list? 'reset expr) (cpc-reset expr kont))
        ((tagged-list? 'shift expr) (cpc-shift expr kont))
        ('else (cpc-app expr kont))))

(define (cpc-simple expr)
  (cond ((symbol? expr) (cpc-symbol expr))
        ((number? expr) (cpc-number expr))
        ((nil? expr) (cpc-nil expr))
        ((char? expr) (cpc-character expr))
        ((tagged-list? 'quote expr) (cpc-quote expr))
        ((tagged-list? 'lambda expr) (cpc-lambda expr))))

(define (cpc-symbol expr)
  (symbol->llvm expr))

(define (cpc-number expr)
  expr)

(define (cpc-nil expr)
  expr)

(define (cpc-character expr)
  expr)

(define (cpc-quote expr)
  expr)

(define (cpc-lambda expr)
  (let ((ct (gensym 'ct))
        (args (map symbol->llvm (lambda-args expr))))
    `(lambda ,(append args (list ct))
       ,(cpc-sequence (lambda-body expr)
                      (lambda (sts)
                        (returning-last sts
                                        (lambda (s)
                                          `(,ct ,s))))))))

(define (cpc-string expr kont)
  (kont expr)) ;; TODO Add string interpolation.

(define (cpc-vector expr kont)
  (kont expr)) ;; TODO Implement this.

(define (cpc-define expr kont)
  (let* ((name (definition-name expr))
         (safe-name (symbol->llvm name)))
    (kont `(define ,safe-name
             ,(cpc-lambda `(lambda (,@(definition-args expr))
                             ,@(definition-body expr)))))))

(define (cpc-do expr kont)
  (cpc-sequence (do-statements expr)
                (lambda (sts)
                  (returning-last sts kont))))

(define (cpc-sequence exprs kont)
  (if (empty? exprs)
      (kont nil)
      (cpc (first-statement exprs)
           (lambda (fst)
             (cpc-sequence (rest-statements exprs)
                           (lambda (rst)
                             (kont (cons fst rst))))))))

(define (returning-last statements kont)
  `(do ,@(returning-last* statements kont)))

(define (returning-last* statements kont)
  (if (empty? (rest-statements statements))
      (list  (kont (first-statement statements)))
      (cons (first-statement statements)
            (returning-last* (rest-statements statements)
                             kont))))

(define (cpc-if expr kont)
  (let* ((ct (gensym 'cont))
         (value (gensym 'value))
         (cont `(lambda (,value) ,(kont value))))
    (cpc (if-predicate expr)
         (lambda (condition)
           `(let ((,ct ,cont))
              (if ,condition
                  ,(cpc (if-then expr) (lambda (v) `(,ct ,v)))
                  ,(cpc (if-else expr) (lambda (v) `(,ct ,v)))))))))

(define (cpc-letcc expr kont)
  (let* ((cc (symbol->llvm (let-bindings expr)))
         (v1 (gensym 'value))
         (v2 (gensym 'value))
         (ct (gensym 'cont)))
    `(let ((,ct (lambda (,v1) ,(kont v1)))
           (,cc (lambda (,v2 ,(gensym 'ignored))
                  (,ct ,v2))))
       ,(cpc-sequence (let-body expr)
                      (lambda (sts)
                        (returning-last sts ct))))))

(define (cpc-letrec expr kont)
  ;; TODO Actually implement this.
  expr)

(define (cpc-reset expr kont)
  (let* ((value (gensym 'value)))
    `((lambda (,value) ,(kont value))
      ;; NOTE This is purely static. Might need some continuation stack
      ;; NOTE maintenance in order to implement push-prompt etc.
      ,(cpc (reset-expr expr)
            (make-identity-continuation)))))

(define (cpc-shift expr kont)
  (let* ((name (symbol->llvm (shift-cont expr)))
         (ct (gensym 'cont))
         (value (gensym 'value)))
    `(let ((,name (lambda (,value ,ct)
                    (,ct ,(kont value)))))
       ,(cpc (shift-expr expr)
             (make-identity-continuation)))))

(define (cpc-app expr kont)
  (let* ((value (gensym 'value))
         (cont `(lambda (,value) ,(kont value))))
    (cpc (app-op expr)
         (lambda (op)
           (cpc-sequence (app-args expr)
                         (lambda (args)
                           `(,op ,@args ,cont)))))))
