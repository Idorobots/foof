;; Continuation Passing Converter
;; Assumes macro-expanded code.

(define (cpc expr cont)
  (cond ((simple-expression? expr) (cpc-simple expr cont))
        ((string? expr) (cpc-string expr cont))
        ((vector? expr) (cpc-vector expr cont))
        ((tagged-list? 'define expr) (cpc-define expr cont))
        ((tagged-list? 'do expr) (cpc-do expr cont))
        ((tagged-list? 'if expr) (cpc-if expr cont))
        ((tagged-list? 'letcc expr) (cpc-letcc expr cont))
        ((tagged-list? 'letrec expr) (cpc-letrec expr cont))
        ((tagged-list? 'reset expr) (cpc-reset expr cont))
        ((tagged-list? 'shift expr) (cpc-shift expr cont))
        ('else (cpc-app expr cont))))

(define (tagged-list? tag lst)
  (and (pair? lst) (eq? (car lst) tag)))

(define (simple-expression? expr)
  (or (symbol? expr)
     (number? expr)
     (char? expr)
     (tagged-list? 'quote expr)
     (tagged-list? 'lambda expr)))

(define (cpc-simple expr cont)
  `(,cont ,(cpc-build-simple expr)))

(define (cpc-build-simple expr)
  (cond ((symbol? expr) (cpc-symbol expr))
        ((number? expr) (cpc-number expr))
        ((char? expr) (cpc-character expr))
        ((tagged-list? 'quote expr) (cpc-quote expr))
        ((tagged-list? 'lambda expr) (cpc-lambda expr))))

(define (cpc-symbol expr)
  (symbol->llvm expr))

(define (cpc-number expr)
  expr)

(define (cpc-character expr)
  expr)

(define (cpc-quote expr)
  expr)

(define (cpc-lambda expr)
  (let ((ct (gensym 'ct))
        (args (map symbol->llvm (lambda-args expr))))
    `(lambda ,(append args (list ct))
       ,@(cpc-sequence (lambda-body expr) ct))))

(define (lambda-args expr)
  (cadr expr))

(define (lambda-body expr)
  (cddr expr))

(define (cpc-string expr cont)
  expr) ;; FIXME Add string interpolation.

(define (cpc-vector expr cont)
  expr) ;; FIXME Implement this.

(define (cpc-define expr cont)
  (let* ((name (definition-name expr))
         (safe-name (symbol->llvm name)))
    `(,cont (define ,safe-name
              ,(cpc-lambda `(lambda (,@(definition-args expr))
                              ,@(definition-body expr)))))))

(define (definition-name expr)
  (caadr expr))

(define (definition-args expr)
  (cdadr expr))

(define (definition-body expr)
  (cddr expr))

(define (cpc-do expr cont)
  `(,cont ,@(cpc-sequence (do-statements expr) cont)))

(define (cpc-sequence statements cont)
  (list (if (empty? (rest-statements statements))
            (cpc (first-statement statements) cont)
            (cpc (first-statement statements)
                 (make-continuation (gensym 'ignored)
                                    (cpc-sequence (rest-statements statements)
                                                  cont))))))

(define (make-continuation arg-name body)
  `(lambda (,arg-name)
     ,@body))

(define (do-statements expr)
  (cdr expr))

(define (first-statement statements)
  (car statements))

(define (rest-statements statements)
  (cdr statements))

(define (cpc-if expr cont)
  (let ((ct (gensym 'ct)))
    `((lambda (,ct)
        ,(cpc (if-predicate expr)
              (let ((value (gensym 'value)))
                (make-continuation value
                                   `((if ,value
                                         ,(cpc (if-then expr) ct)
                                         ,(cpc (if-else expr) ct)))))))
      ,cont)))

(define (if-predicate expr)
  (cadr expr))

(define (if-then expr)
  (caddr expr))

(define (if-else expr)
  (cadddr expr))

(define (cpc-letcc expr cont)
  (let ((cc (let-bindings expr))
        (body (let-body expr))
        (ct (gensym 'cont))
        (arg (gensym 'arg))
        (ignored (gensym 'ignored)))
    `(let ((,ct ,cont))
       (let ((,cc (lambda (,arg ,ignored) (,ct ,arg))))
         ,@(cpc-sequence body ct)))))

(define (cpc-letrec expr cont)
  ;; TODO Actually implement this.
  expr)

(define (cpc-reset expr cont)
  `(do (push-cont! ,cont)
       ,(cpc (reset-expr expr) (make-identity-continuation))))

(define (reset-expr expr)
  (cadr expr))

(define (cpc-shift expr cont)
  (let ((sc (gensym 'cont))
        (arg (gensym 'arg))
        (ignored (gensym 'ignored)))
    `(let ((,(shift-cont expr) (lambda (,arg ,ignored) (,cont ,arg)))
           (,sc (pop-cont!)))
       (,sc ,(cpc (shift-expr expr) cont)))))

(define (shift-cont expr)
  (cadr expr))

(define (shift-expr expr)
  (caddr expr))

(define (cpc-app expr cont)
  (let ((exprs (cpc-build-simple-app expr nil nil)))
    (cpc-build-app (car exprs)
                   (cdr exprs)
                   (reverse (cons cont (cdr exprs))))))

(define (cpc-build-simple-app expr todo exprs)
  (cond ((empty? expr) (cons todo exprs))
        ((simple-expression? (car expr)) (cpc-build-simple-app (cdr expr)
                                                               (cons nil todo)
                                                               ;; FIXME Cant pass nil here.
                                                               (cons (cpc (car expr) nil)
                                                                     exprs)))
        (true (cpc-build-simple-app (cdr expr)
                                    (cons (car expr) todo)
                                    (cons (gensym 'temp) exprs)))))

(define (cpc-build-app todo vals finally)
  (cond ((empty? todo) finally)
        ((nil? (car todo)) (cpc-build-app (cdr todo)
                                          (cdr vals)
                                          finally))
        ('else (cpc-build-app (cdr todo)
                              (cdr vals)
                              (cpc (car todo)
                                   `(lambda (,(car vals))
                                      ,finally))))))
